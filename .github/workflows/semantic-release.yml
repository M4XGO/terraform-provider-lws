name: Release Pipeline

on:
  push:
    branches:
      - main
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version à releaser (ex: v1.0.0)'
        required: false
        type: string
      force_release:
        description: 'Forcer une release même sans nouveaux commits'
        required: false
        default: false
        type: boolean

permissions:
  contents: write
  issues: write
  pull-requests: write
  packages: write

env:
  NODE_VERSION: '20'
  GO_VERSION: '1.22'
  TERRAFORM_VERSION: '1.6.0'

jobs:
  semantic-release:
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    timeout-minutes: 15
    outputs:
      released: ${{ steps.semantic.outputs.new_release_published }}
      version: ${{ steps.semantic.outputs.new_release_version }}
      tag: ${{ steps.semantic.outputs.new_release_git_tag }}
      gpg_fingerprint: ${{ steps.import_gpg.outputs.fingerprint }}
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}

    - name: Import GPG key
      uses: crazy-max/ghaction-import-gpg@v5
      id: import_gpg
      with:
        gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
        passphrase: ${{ secrets.GPG_PASSPHRASE }}
        git_user_signingkey: true
        git_commit_gpgsign: true
        git_tag_gpgsign: true

    - name: Configure Git with GPG
      run: |
        git config --global user.name "github-actions[bot]"
        git config --global user.email "github-actions[bot]@users.noreply.github.com"
        git config --global user.signingkey ${{ steps.import_gpg.outputs.fingerprint }}
        git config --global commit.gpgsign true
        # Configurer les tags pour semantic-release
        git config --global tag.gpgsign false
        git config --global tag.forceSignAnnotated false
        echo "✅ Git configured with GPG signing (commits only, tags unsigned)"

    - name: Install semantic-release dependencies
      run: |
        # Installation globale avec toutes les dépendances nécessaires
        npm install -g semantic-release@^22.0.0 @semantic-release/changelog@^6.0.0 @semantic-release/git@^10.0.0 @semantic-release/github@^9.0.0 @semantic-release/exec@^6.0.0 conventional-changelog-conventionalcommits@^7.0.0

    - name: Create semantic-release config
      run: |
        cat > .releaserc.json << 'EOF'
        {
          "branches": ["main"],
          "repositoryUrl": "https://github.com/${{ github.repository }}.git",
          "plugins": [
            [
              "@semantic-release/commit-analyzer",
              {
                "preset": "conventionalcommits"
              }
            ],
            [
              "@semantic-release/release-notes-generator",
              {
                "preset": "conventionalcommits"
              }
            ],
            [
              "@semantic-release/changelog",
              {
                "changelogFile": "CHANGELOG.md"
              }
            ],
            [
              "@semantic-release/exec",
              {
                "prepareCmd": "echo 'Preparing release ${nextRelease.version}'"
              }
            ],
            [
              "@semantic-release/github",
              {
                "assets": [],
                "releasedLabels": false,
                "addReleases": "bottom",
                "failComment": false,
                "failTitle": false,
                "labels": false,
                "assignees": false
              }
            ],
            [
              "@semantic-release/git",
              {
                "assets": ["CHANGELOG.md"],
                "message": "chore(release): \${nextRelease.version} [skip ci]",
                "tagMessage": "Release \${nextRelease.version}"
              }
            ]
          ]
        }
        EOF

    - name: Run semantic-release
      id: semantic
      run: |
        # Utiliser semantic-release global installé
        semantic-release
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        GIT_AUTHOR_NAME: github-actions[bot]
        GIT_AUTHOR_EMAIL: github-actions[bot]@users.noreply.github.com
        GIT_COMMITTER_NAME: github-actions[bot]
        GIT_COMMITTER_EMAIL: github-actions[bot]@users.noreply.github.com
        # Optimisations pour éviter les timeouts
        SEMANTIC_RELEASE_PACKAGE: ${{ github.repository }}
        CI: true

    - name: Summary
      if: steps.semantic.outputs.new_release_published == 'true'
      run: |
        echo "🎉 New release published!"
        echo "Version: ${{ steps.semantic.outputs.new_release_version }}"
        echo "Tag: ${{ steps.semantic.outputs.new_release_git_tag }}"

  goreleaser:
    runs-on: ubuntu-latest
    needs: [semantic-release]
    timeout-minutes: 30
    if: |
      always() && (
        needs.semantic-release.outputs.released == 'true' ||
        github.event_name == 'workflow_dispatch' ||
        startsWith(github.ref, 'refs/tags/v')
      )
    outputs:
      upload_url: ${{ steps.release.outputs.upload_url }}
      tag: ${{ steps.extract_tag.outputs.tag }}
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Extract tag
      id: extract_tag
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ github.event.inputs.version }}" ]; then
          echo "tag=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
        elif [ "${{ needs.semantic-release.outputs.released }}" = "true" ]; then
          echo "tag=${{ needs.semantic-release.outputs.tag }}" >> $GITHUB_OUTPUT
        elif [ "${{ github.event_name }}" = "push" ] && [[ "${{ github.ref }}" == refs/tags/v* ]]; then
          echo "tag=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT
        else
          echo "❌ Impossible de déterminer le tag"
          exit 1
        fi

    - name: Set up Go
      uses: actions/setup-go@v5
      with:
        go-version: ${{ env.GO_VERSION }}
        cache: true

    - name: Import GPG key
      uses: crazy-max/ghaction-import-gpg@v5
      id: import_gpg
      with:
        gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
        passphrase: ${{ secrets.GPG_PASSPHRASE }}
        git_user_signingkey: true
        git_commit_gpgsign: true
        git_tag_gpgsign: true

    - name: Configure GPG for signing
      run: |
        echo "📋 Configuration GPG pour la signature des artefacts..."
        echo "GPG fingerprint: ${{ steps.import_gpg.outputs.fingerprint }}"
        
        # Configurer l'environnement GPG
        export GPG_TTY=$(tty)
        echo "GPG_TTY=$GPG_TTY" >> $GITHUB_ENV
        
        # Tester la signature GPG
        echo "test" | gpg --armor --detach-sign --local-user ${{ steps.import_gpg.outputs.fingerprint }}
        echo "✅ Test de signature GPG réussi"
        
        # Lister les clés disponibles
        gpg --list-secret-keys --keyid-format LONG

    - name: Run tests
      run: |
        go mod download
        make test

    - name: Check GoReleaser config
      uses: goreleaser/goreleaser-action@v5
      with:
        distribution: goreleaser
        version: v1.26.2
        args: check

    - name: Run GoReleaser
      uses: goreleaser/goreleaser-action@v5
      with:
        distribution: goreleaser
        version: v1.26.2
        args: release --clean
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        GPG_FINGERPRINT: ${{ steps.import_gpg.outputs.fingerprint }}
        GPG_TTY: ${{ env.GPG_TTY }}
        GORELEASER_DEBUG: "true"

    - name: Verify GPG signatures
      run: |
        echo "🔍 Vérification des signatures PGP générées..."
        
        # Chercher les fichiers de signature
        find dist/ -name "*.sig" -type f | while read sig_file; do
          echo "📝 Fichier de signature trouvé: $sig_file"
          
          # Vérifier la signature
          original_file="${sig_file%.sig}"
          if [ -f "$original_file" ]; then
            echo "✅ Vérification de $original_file avec $sig_file"
            gpg --verify "$sig_file" "$original_file" || echo "⚠️ Échec de vérification pour $sig_file"
          else
            echo "❌ Fichier original non trouvé pour $sig_file"
          fi
        done
        
        # Lister tous les artefacts créés
        echo "📦 Artefacts créés:"
        ls -la dist/

    - name: Upload artifacts to job outputs
      id: release
      run: |
        echo "upload_url=https://github.com/${{ github.repository }}/releases/tag/${{ steps.extract_tag.outputs.tag }}" >> $GITHUB_OUTPUT

  validate-terraform-registry:
    runs-on: ubuntu-latest
    needs: [goreleaser]
    timeout-minutes: 20
    strategy:
      matrix:
        terraform-version: ['1.5.0', '1.6.0', '1.7.0']
        os: [ubuntu-latest, macos-latest, windows-latest]
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Set up Terraform ${{ matrix.terraform-version }}
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ matrix.terraform-version }}

    - name: Create test Terraform configuration
      run: |
        mkdir -p test-config
        cat > test-config/main.tf << 'EOF'
        terraform {
          required_version = ">= 1.5.0"
          required_providers {
            lws = {
              source  = "maximenony/lws"
              version = "${{ needs.goreleaser.outputs.tag }}"
            }
          }
        }

        provider "lws" {
          # Configuration will be provided via environment variables
        }

        # Test data source
        data "lws_dns_zone" "test" {
          name = "example.com"
        }
        EOF

    - name: Test Terraform init
      run: |
        cd test-config
        terraform init -upgrade
      env:
        TF_LOG: DEBUG

    - name: Test Terraform validate
      run: |
        cd test-config
        terraform validate

  create-provider-badge:
    runs-on: ubuntu-latest
    needs: [goreleaser, validate-terraform-registry]
    if: always() && needs.goreleaser.result == 'success'
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Update README with badge
      run: |
        # Créer ou mettre à jour le badge Terraform Provider
        BADGE='[![Terraform Provider](https://img.shields.io/badge/terraform-provider-623CE4?style=flat&logo=terraform)](https://registry.terraform.io/providers/maximenony/lws/latest)'
        REGISTRY_BADGE='[![Terraform Registry](https://img.shields.io/badge/terraform-registry-623CE4?style=flat&logo=terraform)](https://registry.terraform.io/providers/maximenony/lws/latest)'
        VERSION_BADGE="[![Latest Release](https://img.shields.io/github/v/release/maximenony/terraform-provider-lws?style=flat&logo=github)](https://github.com/maximenony/terraform-provider-lws/releases/latest)"
        
        # Ajouter les badges en haut du README s'ils ne sont pas déjà présents
        if ! grep -q "terraform-provider" README.md; then
          echo "Ajout des badges au README..."
          sed -i '1i\\n'"$BADGE"' '"$REGISTRY_BADGE"' '"$VERSION_BADGE"'\n' README.md
        fi

    - name: Commit badge changes
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add README.md
        if git diff --staged --quiet; then
          echo "Aucun changement à committer"
        else
          git commit -m "docs: update badges for release ${{ needs.goreleaser.outputs.tag }}"
          git push
        fi

  notify-success:
    runs-on: ubuntu-latest
    needs: [semantic-release, goreleaser, validate-terraform-registry, create-provider-badge]
    if: always()
    steps:
    - name: Report results
      run: |
        echo "## 🎉 Release Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Trigger:** ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
        echo "**Version:** ${{ needs.goreleaser.outputs.tag }}" >> $GITHUB_STEP_SUMMARY
        echo "**Semantic Release:** ${{ needs.semantic-release.result }}" >> $GITHUB_STEP_SUMMARY
        echo "**GoReleaser:** ${{ needs.goreleaser.result }}" >> $GITHUB_STEP_SUMMARY
        echo "**Terraform Validation:** ${{ needs.validate-terraform-registry.result }}" >> $GITHUB_STEP_SUMMARY
        echo "**Badge Update:** ${{ needs.create-provider-badge.result }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### 📦 Artifacts" >> $GITHUB_STEP_SUMMARY
        echo "- [GitHub Release](https://github.com/${{ github.repository }}/releases/tag/${{ needs.goreleaser.outputs.tag }})" >> $GITHUB_STEP_SUMMARY
        echo "- [Terraform Registry](https://registry.terraform.io/providers/maximenony/lws/latest)" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### 🚀 Usage" >> $GITHUB_STEP_SUMMARY
        echo '```hcl' >> $GITHUB_STEP_SUMMARY
        echo 'terraform {' >> $GITHUB_STEP_SUMMARY
        echo '  required_providers {' >> $GITHUB_STEP_SUMMARY
        echo '    lws = {' >> $GITHUB_STEP_SUMMARY
        echo '      source  = "maximenony/lws"' >> $GITHUB_STEP_SUMMARY
        echo '      version = "${{ needs.goreleaser.outputs.tag }}"' >> $GITHUB_STEP_SUMMARY
        echo '    }' >> $GITHUB_STEP_SUMMARY
        echo '  }' >> $GITHUB_STEP_SUMMARY
        echo '}' >> $GITHUB_STEP_SUMMARY
        echo '```' >> $GITHUB_STEP_SUMMARY
        
        if [ "${{ needs.goreleaser.result }}" = "success" ] && [ "${{ needs.validate-terraform-registry.result }}" = "success" ]; then
          echo "✅ Release completed successfully!"
        else
          echo "❌ Release failed. Check the logs above."
          exit 1
        fi 