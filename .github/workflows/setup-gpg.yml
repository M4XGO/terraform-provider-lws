name: Setup GPG for Terraform Registry

on:
  workflow_dispatch:
    inputs:
      force_regenerate:
        description: 'Force regenerate GPG keys even if they exist'
        required: false
        default: false
        type: boolean

jobs:
  setup-gpg:
    name: Setup GPG Keys
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Check if GPG secrets exist
      id: check_secrets
      run: |
        # VÃ©rifier si les secrets existent en tentant de les utiliser
        if [ -n "${{ secrets.GPG_PRIVATE_KEY }}" ] && [ -n "${{ secrets.GPG_PASSPHRASE }}" ]; then
          echo "gpg_exists=true" >> $GITHUB_OUTPUT
          echo "âœ… GPG secrets already exist"
        else
          echo "gpg_exists=false" >> $GITHUB_OUTPUT
          echo "âŒ GPG secrets missing"
        fi

    - name: Generate GPG keys
      if: steps.check_secrets.outputs.gpg_exists == 'false' || github.event.inputs.force_regenerate == 'true'
      id: generate_gpg
      run: |
        echo "ðŸ”‘ Generating GPG key pair..."
        
        # CrÃ©er un rÃ©pertoire temporaire sÃ©curisÃ©
        export GNUPGHOME=$(mktemp -d)
        chmod 700 $GNUPGHOME
        
        # Configuration GPG pour l'automatisation
        cat > $GNUPGHOME/gpg.conf << EOF
        use-agent
        pinentry-mode loopback
        EOF
        
        # GÃ©nÃ©rer une passphrase alÃ©atoire sÃ©curisÃ©e
        GPG_PASSPHRASE=$(openssl rand -base64 32)
        echo "GPG_PASSPHRASE=$GPG_PASSPHRASE" >> $GITHUB_OUTPUT
        
        # Batch de gÃ©nÃ©ration GPG
        cat > gpg-batch << EOF
        %echo Generating GPG key for Terraform Provider LWS
        Key-Type: RSA
        Key-Length: 4096
        Subkey-Type: RSA
        Subkey-Length: 4096
        Name-Real: Terraform Provider LWS
        Name-Email: terraform-provider-lws@M4XGO.com
        Name-Comment: Automated GPG key for Terraform Registry
        Expire-Date: 2y
        Passphrase: $GPG_PASSPHRASE
        %commit
        %echo Done
        EOF
        
        # GÃ©nÃ©rer la clÃ©
        gpg --batch --generate-key gpg-batch
        
        # RÃ©cupÃ©rer l'ID de la clÃ©
        GPG_KEY_ID=$(gpg --list-secret-keys --keyid-format LONG | grep sec | head -1 | cut -d'/' -f2 | cut -d' ' -f1)
        echo "GPG_KEY_ID=$GPG_KEY_ID" >> $GITHUB_OUTPUT
        echo "âœ… Generated GPG key: $GPG_KEY_ID"
        
        # Exporter la clÃ© privÃ©e
        gpg --batch --yes --pinentry-mode loopback --passphrase "$GPG_PASSPHRASE" \
            --armor --export-secret-key $GPG_KEY_ID > private.key
        
        # Encoder en base64 pour Ã©viter les problÃ¨mes de formatting
        base64 -w 0 private.key > private.key.b64
        echo "GPG_PRIVATE_KEY_B64=$(cat private.key.b64)" >> $GITHUB_OUTPUT
        
        # Nettoyer les fichiers temporaires
        rm -f gpg-batch private.key private.key.b64
        rm -rf $GNUPGHOME
        
        echo "ðŸ” GPG key generated successfully"

    - name: Update GitHub Secrets
      if: steps.check_secrets.outputs.gpg_exists == 'false' || github.event.inputs.force_regenerate == 'true'
      run: |
        echo "ðŸ“¤ Updating GitHub secrets..."
        
        # DÃ©coder la clÃ© privÃ©e
        echo "${{ steps.generate_gpg.outputs.GPG_PRIVATE_KEY_B64 }}" | base64 -d > private.key
        
        # Utiliser gh CLI pour mettre Ã  jour les secrets
        echo "${{ steps.generate_gpg.outputs.GPG_PASSPHRASE }}" | gh secret set GPG_PASSPHRASE
        gh secret set GPG_PRIVATE_KEY < private.key
        
        # Nettoyer
        rm -f private.key
        
        echo "âœ… GitHub secrets updated successfully"
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Trigger release workflow
      if: steps.check_secrets.outputs.gpg_exists == 'false' || github.event.inputs.force_regenerate == 'true'
      run: |
        echo "ðŸš€ Triggering new release to test GPG signing..."
        
        # CrÃ©er un commit vide pour dÃ©clencher semantic-release
        git config --global user.name "github-actions[bot]"
        git config --global user.email "github-actions[bot]@users.noreply.github.com"
        
        git commit --allow-empty -m "ci: trigger release with GPG signing enabled
        
        - GPG keys automatically generated and configured
        - This should resolve Terraform Registry validation errors
        - SHASUMS files and signatures will now be created"
        
        git push origin main
        
        echo "âœ… Release triggered successfully"
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Summary
      run: |
        echo "## ðŸŽ‰ GPG Setup Complete!" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### âœ… Actions Completed:" >> $GITHUB_STEP_SUMMARY
        echo "- GPG key pair generated automatically" >> $GITHUB_STEP_SUMMARY
        echo "- GitHub secrets configured (GPG_PRIVATE_KEY, GPG_PASSPHRASE)" >> $GITHUB_STEP_SUMMARY
        echo "- New release triggered to test GPG signing" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸ“‹ Expected Results:" >> $GITHUB_STEP_SUMMARY
        echo "- âœ… SHASUMS file will be created" >> $GITHUB_STEP_SUMMARY
        echo "- âœ… SHASUMS.sig signature file will be created" >> $GITHUB_STEP_SUMMARY
        echo "- âœ… Multi-platform binaries will be available" >> $GITHUB_STEP_SUMMARY
        echo "- âœ… Terraform Registry errors should be resolved" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸ”— Next Steps:" >> $GITHUB_STEP_SUMMARY
        echo "1. Wait for the release workflow to complete" >> $GITHUB_STEP_SUMMARY
        echo "2. Check GitHub Releases for the new artifacts" >> $GITHUB_STEP_SUMMARY
        echo "3. Verify on registry.terraform.io (after registration)" >> $GITHUB_STEP_SUMMARY 